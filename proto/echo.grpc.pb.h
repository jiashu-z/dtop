// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: echo.proto
#ifndef GRPC_echo_2eproto__INCLUDED
#define GRPC_echo_2eproto__INCLUDED

#include "echo.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

class EchoService final {
 public:
  static constexpr char const* service_full_name() {
    return "EchoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status EchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::StringMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>> AsyncEchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>>(AsyncEchoStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>> PrepareAsyncEchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>>(PrepareAsyncEchoStringRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::IntegerMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>> AsyncEchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>>(AsyncEchoIntegerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>> PrepareAsyncEchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>>(PrepareAsyncEchoIntegerRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::LongMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>> AsyncEchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>>(AsyncEchoLongRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>> PrepareAsyncEchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>>(PrepareAsyncEchoLongRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::FloatMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>> AsyncEchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>>(AsyncEchoFloatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>> PrepareAsyncEchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>>(PrepareAsyncEchoFloatRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::DoubleMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>> AsyncEchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>>(AsyncEchoDoubleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>> PrepareAsyncEchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>>(PrepareAsyncEchoDoubleRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::StringArrayMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>> AsyncEchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>>(AsyncEchoStringArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>> PrepareAsyncEchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>>(PrepareAsyncEchoStringArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::IntegerArrayMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>> AsyncEchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>>(AsyncEchoIntegerArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>> PrepareAsyncEchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>>(PrepareAsyncEchoIntegerArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::LongArrayMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>> AsyncEchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>>(AsyncEchoLongArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>> PrepareAsyncEchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>>(PrepareAsyncEchoLongArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::FloatArrayMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>> AsyncEchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>>(AsyncEchoFloatArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>> PrepareAsyncEchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>>(PrepareAsyncEchoFloatArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::DoubleArrayMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>> AsyncEchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>>(AsyncEchoDoubleArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>> PrepareAsyncEchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>>(PrepareAsyncEchoDoubleArrayRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>* AsyncEchoStringRaw(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::StringMessage>* PrepareAsyncEchoStringRaw(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>* AsyncEchoIntegerRaw(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IntegerMessage>* PrepareAsyncEchoIntegerRaw(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>* AsyncEchoLongRaw(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LongMessage>* PrepareAsyncEchoLongRaw(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>* AsyncEchoFloatRaw(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FloatMessage>* PrepareAsyncEchoFloatRaw(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>* AsyncEchoDoubleRaw(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DoubleMessage>* PrepareAsyncEchoDoubleRaw(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>* AsyncEchoStringArrayRaw(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::StringArrayMessage>* PrepareAsyncEchoStringArrayRaw(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>* AsyncEchoIntegerArrayRaw(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IntegerArrayMessage>* PrepareAsyncEchoIntegerArrayRaw(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>* AsyncEchoLongArrayRaw(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LongArrayMessage>* PrepareAsyncEchoLongArrayRaw(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>* AsyncEchoFloatArrayRaw(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::FloatArrayMessage>* PrepareAsyncEchoFloatArrayRaw(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>* AsyncEchoDoubleArrayRaw(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DoubleArrayMessage>* PrepareAsyncEchoDoubleArrayRaw(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status EchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::StringMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringMessage>> AsyncEchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringMessage>>(AsyncEchoStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringMessage>> PrepareAsyncEchoString(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringMessage>>(PrepareAsyncEchoStringRaw(context, request, cq));
    }
    ::grpc::Status EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::IntegerMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerMessage>> AsyncEchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerMessage>>(AsyncEchoIntegerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerMessage>> PrepareAsyncEchoInteger(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerMessage>>(PrepareAsyncEchoIntegerRaw(context, request, cq));
    }
    ::grpc::Status EchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::LongMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongMessage>> AsyncEchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongMessage>>(AsyncEchoLongRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongMessage>> PrepareAsyncEchoLong(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongMessage>>(PrepareAsyncEchoLongRaw(context, request, cq));
    }
    ::grpc::Status EchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::FloatMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatMessage>> AsyncEchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatMessage>>(AsyncEchoFloatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatMessage>> PrepareAsyncEchoFloat(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatMessage>>(PrepareAsyncEchoFloatRaw(context, request, cq));
    }
    ::grpc::Status EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::DoubleMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleMessage>> AsyncEchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleMessage>>(AsyncEchoDoubleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleMessage>> PrepareAsyncEchoDouble(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleMessage>>(PrepareAsyncEchoDoubleRaw(context, request, cq));
    }
    ::grpc::Status EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::StringArrayMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>> AsyncEchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>>(AsyncEchoStringArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>> PrepareAsyncEchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>>(PrepareAsyncEchoStringArrayRaw(context, request, cq));
    }
    ::grpc::Status EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::IntegerArrayMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>> AsyncEchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>>(AsyncEchoIntegerArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>> PrepareAsyncEchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>>(PrepareAsyncEchoIntegerArrayRaw(context, request, cq));
    }
    ::grpc::Status EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::LongArrayMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>> AsyncEchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>>(AsyncEchoLongArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>> PrepareAsyncEchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>>(PrepareAsyncEchoLongArrayRaw(context, request, cq));
    }
    ::grpc::Status EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::FloatArrayMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>> AsyncEchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>>(AsyncEchoFloatArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>> PrepareAsyncEchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>>(PrepareAsyncEchoFloatArrayRaw(context, request, cq));
    }
    ::grpc::Status EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::DoubleArrayMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>> AsyncEchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>>(AsyncEchoDoubleArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>> PrepareAsyncEchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>>(PrepareAsyncEchoDoubleArrayRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoString(::grpc::ClientContext* context, const ::StringMessage* request, ::StringMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoInteger(::grpc::ClientContext* context, const ::IntegerMessage* request, ::IntegerMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoLong(::grpc::ClientContext* context, const ::LongMessage* request, ::LongMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoFloat(::grpc::ClientContext* context, const ::FloatMessage* request, ::FloatMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoDouble(::grpc::ClientContext* context, const ::DoubleMessage* request, ::DoubleMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoStringArray(::grpc::ClientContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoIntegerArray(::grpc::ClientContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoLongArray(::grpc::ClientContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoFloatArray(::grpc::ClientContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EchoDoubleArray(::grpc::ClientContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::StringMessage>* AsyncEchoStringRaw(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::StringMessage>* PrepareAsyncEchoStringRaw(::grpc::ClientContext* context, const ::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IntegerMessage>* AsyncEchoIntegerRaw(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IntegerMessage>* PrepareAsyncEchoIntegerRaw(::grpc::ClientContext* context, const ::IntegerMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LongMessage>* AsyncEchoLongRaw(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LongMessage>* PrepareAsyncEchoLongRaw(::grpc::ClientContext* context, const ::LongMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::FloatMessage>* AsyncEchoFloatRaw(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::FloatMessage>* PrepareAsyncEchoFloatRaw(::grpc::ClientContext* context, const ::FloatMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DoubleMessage>* AsyncEchoDoubleRaw(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DoubleMessage>* PrepareAsyncEchoDoubleRaw(::grpc::ClientContext* context, const ::DoubleMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>* AsyncEchoStringArrayRaw(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::StringArrayMessage>* PrepareAsyncEchoStringArrayRaw(::grpc::ClientContext* context, const ::StringArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>* AsyncEchoIntegerArrayRaw(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IntegerArrayMessage>* PrepareAsyncEchoIntegerArrayRaw(::grpc::ClientContext* context, const ::IntegerArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>* AsyncEchoLongArrayRaw(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LongArrayMessage>* PrepareAsyncEchoLongArrayRaw(::grpc::ClientContext* context, const ::LongArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>* AsyncEchoFloatArrayRaw(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::FloatArrayMessage>* PrepareAsyncEchoFloatArrayRaw(::grpc::ClientContext* context, const ::FloatArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>* AsyncEchoDoubleArrayRaw(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DoubleArrayMessage>* PrepareAsyncEchoDoubleArrayRaw(::grpc::ClientContext* context, const ::DoubleArrayMessage& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_EchoString_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoInteger_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoLong_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoFloat_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoDouble_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoStringArray_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoIntegerArray_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoLongArray_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoFloatArray_;
    const ::grpc::internal::RpcMethod rpcmethod_EchoDoubleArray_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status EchoString(::grpc::ServerContext* context, const ::StringMessage* request, ::StringMessage* response);
    virtual ::grpc::Status EchoInteger(::grpc::ServerContext* context, const ::IntegerMessage* request, ::IntegerMessage* response);
    virtual ::grpc::Status EchoLong(::grpc::ServerContext* context, const ::LongMessage* request, ::LongMessage* response);
    virtual ::grpc::Status EchoFloat(::grpc::ServerContext* context, const ::FloatMessage* request, ::FloatMessage* response);
    virtual ::grpc::Status EchoDouble(::grpc::ServerContext* context, const ::DoubleMessage* request, ::DoubleMessage* response);
    virtual ::grpc::Status EchoStringArray(::grpc::ServerContext* context, const ::StringArrayMessage* request, ::StringArrayMessage* response);
    virtual ::grpc::Status EchoIntegerArray(::grpc::ServerContext* context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response);
    virtual ::grpc::Status EchoLongArray(::grpc::ServerContext* context, const ::LongArrayMessage* request, ::LongArrayMessage* response);
    virtual ::grpc::Status EchoFloatArray(::grpc::ServerContext* context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response);
    virtual ::grpc::Status EchoDoubleArray(::grpc::ServerContext* context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoString() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoString(::grpc::ServerContext* context, ::StringMessage* request, ::grpc::ServerAsyncResponseWriter< ::StringMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoInteger() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoInteger(::grpc::ServerContext* context, ::IntegerMessage* request, ::grpc::ServerAsyncResponseWriter< ::IntegerMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoLong() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoLong(::grpc::ServerContext* context, ::LongMessage* request, ::grpc::ServerAsyncResponseWriter< ::LongMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoFloat() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoFloat(::grpc::ServerContext* context, ::FloatMessage* request, ::grpc::ServerAsyncResponseWriter< ::FloatMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoDouble() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoDouble(::grpc::ServerContext* context, ::DoubleMessage* request, ::grpc::ServerAsyncResponseWriter< ::DoubleMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoStringArray() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoStringArray(::grpc::ServerContext* context, ::StringArrayMessage* request, ::grpc::ServerAsyncResponseWriter< ::StringArrayMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoIntegerArray() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoIntegerArray(::grpc::ServerContext* context, ::IntegerArrayMessage* request, ::grpc::ServerAsyncResponseWriter< ::IntegerArrayMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoLongArray() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoLongArray(::grpc::ServerContext* context, ::LongArrayMessage* request, ::grpc::ServerAsyncResponseWriter< ::LongArrayMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoFloatArray() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoFloatArray(::grpc::ServerContext* context, ::FloatArrayMessage* request, ::grpc::ServerAsyncResponseWriter< ::FloatArrayMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EchoDoubleArray() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoDoubleArray(::grpc::ServerContext* context, ::DoubleArrayMessage* request, ::grpc::ServerAsyncResponseWriter< ::DoubleArrayMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_EchoString<WithAsyncMethod_EchoInteger<WithAsyncMethod_EchoLong<WithAsyncMethod_EchoFloat<WithAsyncMethod_EchoDouble<WithAsyncMethod_EchoStringArray<WithAsyncMethod_EchoIntegerArray<WithAsyncMethod_EchoLongArray<WithAsyncMethod_EchoFloatArray<WithAsyncMethod_EchoDoubleArray<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoString() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::StringMessage, ::StringMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::StringMessage* request, ::StringMessage* response) { return this->EchoString(context, request, response); }));}
    void SetMessageAllocatorFor_EchoString(
        ::grpc::experimental::MessageAllocator< ::StringMessage, ::StringMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::StringMessage, ::StringMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoString(
      ::grpc::CallbackServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoString(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoInteger() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::IntegerMessage, ::IntegerMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::IntegerMessage* request, ::IntegerMessage* response) { return this->EchoInteger(context, request, response); }));}
    void SetMessageAllocatorFor_EchoInteger(
        ::grpc::experimental::MessageAllocator< ::IntegerMessage, ::IntegerMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IntegerMessage, ::IntegerMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoInteger(
      ::grpc::CallbackServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoInteger(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoLong() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::LongMessage, ::LongMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LongMessage* request, ::LongMessage* response) { return this->EchoLong(context, request, response); }));}
    void SetMessageAllocatorFor_EchoLong(
        ::grpc::experimental::MessageAllocator< ::LongMessage, ::LongMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LongMessage, ::LongMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoLong(
      ::grpc::CallbackServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoLong(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoFloat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::FloatMessage, ::FloatMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::FloatMessage* request, ::FloatMessage* response) { return this->EchoFloat(context, request, response); }));}
    void SetMessageAllocatorFor_EchoFloat(
        ::grpc::experimental::MessageAllocator< ::FloatMessage, ::FloatMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::FloatMessage, ::FloatMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoFloat(
      ::grpc::CallbackServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoFloat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoDouble() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::DoubleMessage, ::DoubleMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::DoubleMessage* request, ::DoubleMessage* response) { return this->EchoDouble(context, request, response); }));}
    void SetMessageAllocatorFor_EchoDouble(
        ::grpc::experimental::MessageAllocator< ::DoubleMessage, ::DoubleMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DoubleMessage, ::DoubleMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoDouble(
      ::grpc::CallbackServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoDouble(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoStringArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::StringArrayMessage, ::StringArrayMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::StringArrayMessage* request, ::StringArrayMessage* response) { return this->EchoStringArray(context, request, response); }));}
    void SetMessageAllocatorFor_EchoStringArray(
        ::grpc::experimental::MessageAllocator< ::StringArrayMessage, ::StringArrayMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::StringArrayMessage, ::StringArrayMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoStringArray(
      ::grpc::CallbackServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoStringArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoIntegerArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::IntegerArrayMessage, ::IntegerArrayMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::IntegerArrayMessage* request, ::IntegerArrayMessage* response) { return this->EchoIntegerArray(context, request, response); }));}
    void SetMessageAllocatorFor_EchoIntegerArray(
        ::grpc::experimental::MessageAllocator< ::IntegerArrayMessage, ::IntegerArrayMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IntegerArrayMessage, ::IntegerArrayMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoIntegerArray(
      ::grpc::CallbackServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoIntegerArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoLongArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::LongArrayMessage, ::LongArrayMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LongArrayMessage* request, ::LongArrayMessage* response) { return this->EchoLongArray(context, request, response); }));}
    void SetMessageAllocatorFor_EchoLongArray(
        ::grpc::experimental::MessageAllocator< ::LongArrayMessage, ::LongArrayMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LongArrayMessage, ::LongArrayMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoLongArray(
      ::grpc::CallbackServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoLongArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoFloatArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::FloatArrayMessage, ::FloatArrayMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::FloatArrayMessage* request, ::FloatArrayMessage* response) { return this->EchoFloatArray(context, request, response); }));}
    void SetMessageAllocatorFor_EchoFloatArray(
        ::grpc::experimental::MessageAllocator< ::FloatArrayMessage, ::FloatArrayMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::FloatArrayMessage, ::FloatArrayMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoFloatArray(
      ::grpc::CallbackServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoFloatArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EchoDoubleArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::DoubleArrayMessage, ::DoubleArrayMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::DoubleArrayMessage* request, ::DoubleArrayMessage* response) { return this->EchoDoubleArray(context, request, response); }));}
    void SetMessageAllocatorFor_EchoDoubleArray(
        ::grpc::experimental::MessageAllocator< ::DoubleArrayMessage, ::DoubleArrayMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DoubleArrayMessage, ::DoubleArrayMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoDoubleArray(
      ::grpc::CallbackServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoDoubleArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_EchoString<ExperimentalWithCallbackMethod_EchoInteger<ExperimentalWithCallbackMethod_EchoLong<ExperimentalWithCallbackMethod_EchoFloat<ExperimentalWithCallbackMethod_EchoDouble<ExperimentalWithCallbackMethod_EchoStringArray<ExperimentalWithCallbackMethod_EchoIntegerArray<ExperimentalWithCallbackMethod_EchoLongArray<ExperimentalWithCallbackMethod_EchoFloatArray<ExperimentalWithCallbackMethod_EchoDoubleArray<Service > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_EchoString<ExperimentalWithCallbackMethod_EchoInteger<ExperimentalWithCallbackMethod_EchoLong<ExperimentalWithCallbackMethod_EchoFloat<ExperimentalWithCallbackMethod_EchoDouble<ExperimentalWithCallbackMethod_EchoStringArray<ExperimentalWithCallbackMethod_EchoIntegerArray<ExperimentalWithCallbackMethod_EchoLongArray<ExperimentalWithCallbackMethod_EchoFloatArray<ExperimentalWithCallbackMethod_EchoDoubleArray<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoString() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoInteger() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoLong() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoFloat() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoDouble() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoStringArray() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoIntegerArray() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoLongArray() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoFloatArray() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EchoDoubleArray() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoString() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoString(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoInteger() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoInteger(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoLong() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoLong(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoFloat() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoFloat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoDouble() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoDouble(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoStringArray() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoStringArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoIntegerArray() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoIntegerArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoLongArray() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoLongArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoFloatArray() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoFloatArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EchoDoubleArray() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEchoDoubleArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoString() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoString(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoString(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoString(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoInteger() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoInteger(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoInteger(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoInteger(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoLong() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoLong(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoLong(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoLong(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoFloat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoFloat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoFloat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoFloat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoDouble() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoDouble(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoDouble(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoDouble(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoStringArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoStringArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoStringArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoStringArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoIntegerArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoIntegerArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoIntegerArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoIntegerArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoLongArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoLongArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoLongArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoLongArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoFloatArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoFloatArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoFloatArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoFloatArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EchoDoubleArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EchoDoubleArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EchoDoubleArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EchoDoubleArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoString() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::StringMessage, ::StringMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::StringMessage, ::StringMessage>* streamer) {
                       return this->StreamedEchoString(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoString(::grpc::ServerContext* /*context*/, const ::StringMessage* /*request*/, ::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoString(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::StringMessage,::StringMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoInteger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoInteger() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IntegerMessage, ::IntegerMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IntegerMessage, ::IntegerMessage>* streamer) {
                       return this->StreamedEchoInteger(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoInteger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoInteger(::grpc::ServerContext* /*context*/, const ::IntegerMessage* /*request*/, ::IntegerMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoInteger(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IntegerMessage,::IntegerMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoLong() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LongMessage, ::LongMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LongMessage, ::LongMessage>* streamer) {
                       return this->StreamedEchoLong(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoLong(::grpc::ServerContext* /*context*/, const ::LongMessage* /*request*/, ::LongMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoLong(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LongMessage,::LongMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoFloat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoFloat() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::FloatMessage, ::FloatMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::FloatMessage, ::FloatMessage>* streamer) {
                       return this->StreamedEchoFloat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoFloat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoFloat(::grpc::ServerContext* /*context*/, const ::FloatMessage* /*request*/, ::FloatMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoFloat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::FloatMessage,::FloatMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoDouble : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoDouble() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DoubleMessage, ::DoubleMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DoubleMessage, ::DoubleMessage>* streamer) {
                       return this->StreamedEchoDouble(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoDouble() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoDouble(::grpc::ServerContext* /*context*/, const ::DoubleMessage* /*request*/, ::DoubleMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoDouble(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DoubleMessage,::DoubleMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoStringArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoStringArray() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::StringArrayMessage, ::StringArrayMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::StringArrayMessage, ::StringArrayMessage>* streamer) {
                       return this->StreamedEchoStringArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoStringArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoStringArray(::grpc::ServerContext* /*context*/, const ::StringArrayMessage* /*request*/, ::StringArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoStringArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::StringArrayMessage,::StringArrayMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoIntegerArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoIntegerArray() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IntegerArrayMessage, ::IntegerArrayMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IntegerArrayMessage, ::IntegerArrayMessage>* streamer) {
                       return this->StreamedEchoIntegerArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoIntegerArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoIntegerArray(::grpc::ServerContext* /*context*/, const ::IntegerArrayMessage* /*request*/, ::IntegerArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoIntegerArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IntegerArrayMessage,::IntegerArrayMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoLongArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoLongArray() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LongArrayMessage, ::LongArrayMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LongArrayMessage, ::LongArrayMessage>* streamer) {
                       return this->StreamedEchoLongArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoLongArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoLongArray(::grpc::ServerContext* /*context*/, const ::LongArrayMessage* /*request*/, ::LongArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoLongArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LongArrayMessage,::LongArrayMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoFloatArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoFloatArray() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::FloatArrayMessage, ::FloatArrayMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::FloatArrayMessage, ::FloatArrayMessage>* streamer) {
                       return this->StreamedEchoFloatArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoFloatArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoFloatArray(::grpc::ServerContext* /*context*/, const ::FloatArrayMessage* /*request*/, ::FloatArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoFloatArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::FloatArrayMessage,::FloatArrayMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EchoDoubleArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EchoDoubleArray() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DoubleArrayMessage, ::DoubleArrayMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DoubleArrayMessage, ::DoubleArrayMessage>* streamer) {
                       return this->StreamedEchoDoubleArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EchoDoubleArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EchoDoubleArray(::grpc::ServerContext* /*context*/, const ::DoubleArrayMessage* /*request*/, ::DoubleArrayMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEchoDoubleArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DoubleArrayMessage,::DoubleArrayMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_EchoString<WithStreamedUnaryMethod_EchoInteger<WithStreamedUnaryMethod_EchoLong<WithStreamedUnaryMethod_EchoFloat<WithStreamedUnaryMethod_EchoDouble<WithStreamedUnaryMethod_EchoStringArray<WithStreamedUnaryMethod_EchoIntegerArray<WithStreamedUnaryMethod_EchoLongArray<WithStreamedUnaryMethod_EchoFloatArray<WithStreamedUnaryMethod_EchoDoubleArray<Service > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_EchoString<WithStreamedUnaryMethod_EchoInteger<WithStreamedUnaryMethod_EchoLong<WithStreamedUnaryMethod_EchoFloat<WithStreamedUnaryMethod_EchoDouble<WithStreamedUnaryMethod_EchoStringArray<WithStreamedUnaryMethod_EchoIntegerArray<WithStreamedUnaryMethod_EchoLongArray<WithStreamedUnaryMethod_EchoFloatArray<WithStreamedUnaryMethod_EchoDoubleArray<Service > > > > > > > > > > StreamedService;
};


#endif  // GRPC_echo_2eproto__INCLUDED
